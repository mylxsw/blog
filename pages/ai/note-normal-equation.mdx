# 跟 GPT 学 AI：Normal Equation

import Meta from 'components/meta';

<Meta author="mylxsw" date={new Date('2024-09-03')} tags={["machine-learning"]} />


import ChatBox from 'components/chat-box';

<ChatBox type="info">
这个函数怎么理解?

```python
def normalEqn(X, y):
    theta = np.linalg.inv(X.T @ X) @ X.T @ y  # X.T @ X等价于X.T.dot(X)
    return theta
```
</ChatBox>



这个函数实现了 **正规方程（Normal Equation）** 方法，用于计算线性回归模型中的最优参数（$\theta$）。正规方程提供了一种不需要使用梯度下降的方式来求解线性回归问题的参数。

### 解释函数 `normalEqn`

#### 1. 正规方程的数学公式

正规方程的公式如下：
$$
\theta = (X^T X)^{-1} X^T y
$$

其中：
- $X$ 是训练数据的特征矩阵，大小为 $m \times n$，其中 $m$ 是样本数量，$n$ 是特征数量（包括常数项 $1$）。
- $y$ 是目标值向量，大小为 $m \times 1$。
- $\theta$ 是线性回归模型的参数向量，大小为 $n \times 1$。

#### 2. 函数步骤解析

- `X.T`: 表示矩阵 $X$ 的转置。假设 $X$ 的形状是 $m \times n$，那么 $X.T$ 的形状是 $n \times m$。
- `X.T @ X` 或 `X.T.dot(X)`: 计算转置矩阵 $X^T$ 与矩阵 $X$ 的乘积，结果是一个 $n \times n$ 的方阵。这相当于计算每对特征之间的内积（计算特征的协方差矩阵）。
- `np.linalg.inv(X.T @ X)`: 计算矩阵 $X^T X$ 的逆矩阵。逆矩阵用于找到参数 $\theta$ 使得误差最小化。
- `X.T @ y`: 计算 $X^T$ 和 $y$ 的乘积，得到一个 $n \times 1$ 的向量。
- `@`: 符号表示矩阵乘法。最终得到的 `theta` 是通过正规方程公式计算出来的最优参数向量。

### 正规方程工作原理的通俗解释

1. **找到误差最小的参数**：
   线性回归的目标是找到一组参数 $\theta$，使得预测值 $h_\theta(X) = X \theta$ 和实际值 $y$ 之间的均方误差最小化。正规方程方法通过解方程 $(X^T X) \theta = X^T y$ 来找到这样一组参数。

2. **为什么可以不用梯度下降**：
   正规方程直接通过公式计算最优解，不需要像梯度下降那样迭代地寻找最优解。因此，不需要选择学习率（$\alpha$）和迭代次数（iters）。但是，正规方程在数据量非常大的时候可能会很慢，因为计算逆矩阵的时间复杂度是 $O(n^3)$。

3. **矩阵的作用**：
   - $X^T X$：相当于“累加”所有样本的特征信息。
   - $X^T y$：“累加”所有样本的特征与输出的关系。
   - 通过求解这个公式，我们可以得到使误差最小的 $\theta$。

### 举例说明

假设你有以下训练数据：

| 样本编号 | $x_0$ | $x_1$ | $y$ |
|----------|---------|---------|-------|
| 1        | 1       | 2104    | 460   |
| 2        | 1       | 1416    | 232   |
| 3        | 1       | 1534    | 315   |
| 4        | 1       | 852     | 178   |

- 其中，$x_0 = 1$ 是偏置项， $x_1$ 是房子的面积， $y$ 是房子的价格。
- $X = \begin{bmatrix} 1 & 2104 \\ 1 & 1416 \\ 1 & 1534 \\ 1 & 852 \end{bmatrix}, y = \begin{bmatrix} 460 \\ 232 \\ 315 \\ 178 \end{bmatrix}$

使用正规方程计算：

$$
\theta = (X^T X)^{-1} X^T y
$$

得到的 $\theta$ 是一个二维向量，包含偏置项的系数和面积的系数，可以用于预测房子的价格。

### 总结

正规方程是一种求解线性回归模型参数的直接方法，它通过矩阵运算得到最小化误差的参数值。理解矩阵运算的意义和目的，可以帮助你更好地掌握机器学习中常用的数学工具。

<ChatBox type="info">点积？</ChatBox>

你提到的“点积”，也称为“内积”，是线性代数中的一种基本操作。它是两个向量之间的乘法运算，结果是一个标量。点积在机器学习、计算机图形学、物理学等领域有广泛的应用。

### 点积的定义

假设有两个向量 $\mathbf{a}$ 和 $\mathbf{b}$：

$$
\mathbf{a} = [a_1, a_2, \ldots, a_n], \quad \mathbf{b} = [b_1, b_2, \ldots, b_n]
$$

这两个向量的**点积**（也称为“内积”）定义为：

$$
\mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + \ldots + a_n b_n = \sum_{i=1}^{n} a_i b_i
$$

点积的结果是一个标量（单个数值），而不是一个向量或矩阵。

### 点积的几何意义

1. **向量之间的关系：**  
   点积可以表示两个向量之间的相似性或关系。当两个向量的点积为零时，它们是正交的（垂直的）。点积的符号可以表示向量之间的方向关系：
   - 如果点积大于零（正数），两个向量在同一方向上的投影方向相同。
   - 如果点积小于零（负数），两个向量的投影方向相反。

2. **向量的长度与角度：**  
   点积还可以用来计算两个向量之间的夹角 $\theta$。如果我们有两个向量 $\mathbf{a}$ 和 $\mathbf{b}$，它们的点积与它们的长度和夹角的余弦相关：

   $$
   \mathbf{a} \cdot \mathbf{b} = \|\mathbf{a}\| \|\mathbf{b}\| \cos(\theta)
   $$

   其中：
   - $\|\mathbf{a}\|$ 和 $\|\mathbf{b}\|$ 是向量的长度（范数）。
   - $\cos(\theta)$ 是两个向量之间的夹角的余弦值。

### 点积在机器学习中的应用

在机器学习，特别是线性回归和逻辑回归中，点积用于计算模型的预测值。假设我们有一个输入特征向量 $\mathbf{x} = [x_1, x_2, \ldots, x_n]$ 和参数向量 $\theta = [\theta_1, \theta_2, \ldots, \theta_n]$，线性回归的假设函数（预测函数）可以表示为：

$$
h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \ldots + \theta_n x_n
$$

用点积表示为：

$$
h_\theta(x) = \mathbf{x} \cdot \theta
$$

其中，假设 $\mathbf{x}$ 包含了一个偏置项（通常是 1），点积计算简化了模型的实现，使得所有特征的权重求和变得简单直接。

### 如何计算点积

用 Python 代码计算点积非常简单，可以使用 `numpy` 库：

```python
import numpy as np

# 定义两个向量
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 计算点积
dot_product = np.dot(a, b)  # 等同于 a @ b
print(dot_product)  # 输出 32
```

在这个例子中，`a` 和 `b` 的点积计算为：

$$
1 \times 4 + 2 \times 5 + 3 \times 6 = 32
$$

### 总结

- **点积**是一个线性代数运算，用于两个向量之间的乘法，结果是一个标量。
- 它在机器学习中广泛用于计算预测值、衡量向量之间的相似性等。
- 在代码实现中，点积运算可以使用 `numpy` 的 `dot` 函数或 `@` 操作符来完成。

<ChatBox type="info">对比下正规方程和梯度下降</ChatBox>

正规方程和梯度下降是两种常用的求解线性回归模型参数的方法。它们各有优缺点，适用于不同的场景。让我们对它们进行详细对比。

### 1. 正规方程（Normal Equation）

#### 工作原理
正规方程通过直接求解最小化平方误差的解析解来计算线性回归模型的参数。它基于以下公式：

$$
\theta = (X^T X)^{-1} X^T y
$$

其中：
- $X$ 是特征矩阵（含偏置项）。
- $y$ 是目标向量。
- $\theta$ 是参数向量（回归系数）。

#### 特点
- **不需要选择学习率（$\alpha$）**：正规方程不需要像梯度下降那样选择一个合适的学习率。
- **不需要迭代**：正规方程通过直接计算逆矩阵来得到参数的最优解，因此不需要多次迭代。
- **适合小数据集**：当特征数量 $n$ 较小时（如 $n < 10,000$），正规方程非常高效。
- **不适合高维数据**：计算 $X^T X$ 的逆矩阵的时间复杂度是 $O(n^3)$，当特征数量 $n$ 很大时（比如 $n > 10,000$），计算逆矩阵会非常慢甚至不可行。此外，特征矩阵可能会是奇异矩阵（不可逆），这时需要使用其他方法。

#### 优点
- **简单直接**：通过一次计算得到结果，适合特征数量较少的情况。
- **无参数调整**：不需要像梯度下降那样选择学习率等超参数，减少了模型调参的复杂度。

#### 缺点
- **计算复杂度高**：当特征数量多时，计算逆矩阵代价非常高。
- **不适合大规模数据**：如果数据量非常大（特征数多），内存和计算资源可能不足以支持计算。

---

### 2. 梯度下降（Gradient Descent）

#### 工作原理
梯度下降是一种迭代优化算法，用于最小化目标函数。对于线性回归模型，其目标函数是均方误差（MSE），梯度下降通过不断更新参数 $\theta$ 来最小化这个误差。

更新规则为：

$$
\theta := \theta - \alpha \frac{1}{m} X^T (X\theta - y)
$$

其中：
- $\alpha$ 是学习率（决定每一步更新的幅度）。
- $m$ 是样本数量。
- $X\theta - y$ 是误差向量。

#### 特点
- **需要选择学习率（$\alpha$）**：学习率的选择非常重要，过大可能导致收敛失败，过小可能导致收敛速度慢。
- **需要迭代**：梯度下降需要通过多次迭代逐步接近最优解，收敛速度取决于学习率和数据特征。
- **适合大规模数据**：梯度下降可以处理特征数量很大的数据集，因为它不需要计算逆矩阵，可以逐步优化。
- **不同的变体**：梯度下降有多种变体，如批量梯度下降（BGD）、随机梯度下降（SGD）、小批量梯度下降（Mini-batch GD）等，适合不同的场景。

#### 优点
- **适合大规模数据**：可以在内存限制的情况下处理非常大的数据集，尤其是特征数量较多时。
- **灵活性高**：通过选择合适的学习率和批量大小，可以在不同的计算环境和数据规模下优化表现。

#### 缺点
- **需要调参**：需要选择合适的学习率和迭代次数，调参较复杂。
- **可能收敛到局部最小值**：对于非凸函数（虽然线性回归是凸函数），可能会陷入局部最小值。
- **慢速收敛**：如果学习率太小，收敛速度会很慢。

---

### 正规方程与梯度下降的对比

| 特性                | 正规方程                      | 梯度下降                                 |
|---------------------|------------------------------|------------------------------------------|
| **计算方式**        | 解析解                       | 迭代优化                                 |
| **计算时间复杂度**  | $O(n^3)$                   | 每次迭代 $O(n)$                        |
| **内存需求**        | 高（需要存储 $X^T X$ 的逆矩阵） | 低（只需存储参数向量）                    |
| **适用数据规模**    | 小数据集（特征数少于 10,000） | 大数据集（特征数和样本量很大）             |
| **调参复杂度**      | 无需调参                     | 需要选择学习率、迭代次数等超参数           |
| **收敛速度**        | 一次计算得到结果              | 依赖于学习率和初始值，可能需要多次迭代    |
| **稳定性**          | 可能因为矩阵不可逆而失败      | 较稳定，收敛到全局最优（对于凸函数）      |

### 总结

- **正规方程**适合数据量较小、特征数量较少的情况，计算简洁，直接求解最优参数，无需调参，但计算复杂度高，可能受限于内存。
- **梯度下降**适合大数据集，具有更好的扩展性和灵活性，但需要选择合适的学习率和迭代次数来确保收敛到最优解。对于特征数量多的数据，梯度下降通常更高效。

选择哪种方法应基于数据规模、特征数量、计算资源和应用场景。