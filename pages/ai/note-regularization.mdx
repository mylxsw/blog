# 跟 GPT 学 AI：Regularization

import Meta from 'components/meta';

<Meta author="mylxsw" date={new Date('2024-09-03')} tags={["machine-learning"]} />


import ChatBox from 'components/chat-box';

## 正则化

<ChatBox type="info">
正则化是什么？
</ChatBox>

**正则化**（Regularization）是一种防止机器学习模型过拟合（overfitting）的技术。过拟合指的是模型在训练数据上表现得非常好，但在新数据上表现较差，因为模型过于复杂、拟合了训练数据中的噪声或异常。正则化通过在模型的损失函数中增加一个**惩罚项**，使模型的参数尽量小，从而简化模型，提升其泛化能力。

### **为什么需要正则化？**
在训练机器学习模型时，如果模型太复杂（例如，具有太多的特征或参数），它可能会记住训练数据中的每一个细节，包括噪声和异常值，这导致模型不能很好地泛化到新的数据上。正则化旨在限制模型的复杂性，减少模型参数的大小，促使模型学到的是数据的主要模式，而不是数据中的噪声。

### **正则化的常见方法**
正则化通常通过在损失函数中添加一个额外的正则化项（也叫惩罚项）来实现。常见的正则化方法包括：

#### **L1正则化（Lasso Regularization）**：
- 在损失函数中加入所有模型参数的**绝对值和**作为惩罚项。
- 正则化项公式为：$\lambda \sum |\theta_i|$
- 优点：可以促使一些不重要的特征权重变为零，从而实现特征选择，有助于得到更稀疏的模型。
- 常用于希望自动选择特征的情况。

#### **L2正则化（Ridge Regularization）**：
- 在损失函数中加入所有模型参数的**平方和**作为惩罚项。
- 正则化项公式为：$\lambda \sum \theta_i^2$
- 优点：会使得所有权重尽可能的小，但不会强迫它们变成零，因此能够避免模型对特定特征的过度依赖。
- 常用于防止模型过拟合，使得模型更稳定。

#### **Elastic Net正则化**：
- 结合了L1和L2正则化的特性，通过惩罚项中同时包含参数的绝对值和平方和来实现。
- 优点：在拥有大量特征的模型中更为有效，尤其当特征数量大于样本数量时。

### **正则化的数学形式**
通常，正则化是在模型的损失函数中添加一个惩罚项。例如，在线性回归中，原始的损失函数是均方误差（MSE）：

$$
J(\theta) = \frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2
$$

正则化后的损失函数为：

- **L2 正则化**（Ridge）：  
$$
J(\theta) = \frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^n \theta_j^2
$$

- **L1 正则化**（Lasso）：  
$$
J(\theta) = \frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^n |\theta_j|
$$

其中，$ \lambda $ 是一个**正则化超参数**，用于控制正则化项的影响大小。如果 $ \lambda $ 太大，模型会欠拟合；如果 $ \lambda $ 太小，模型可能会过拟合。

### **正则化的直观解释**
- 正则化可以看作是对模型参数的惩罚，它鼓励模型使用尽可能小的参数，从而避免学习到训练数据中的噪声。
- 正则化可以使得模型更简单，提升模型在新数据上的表现。

### **总结**
正则化是防止模型过拟合的有效手段。通过在损失函数中增加一个惩罚项，正则化迫使模型的参数尽量小，从而提升模型的泛化能力。常见的正则化方法包括L1正则化、L2正则化和Elastic Net正则化，每种方法都有其适用场景和特点。


## 如何选择正则化超参数 $ \lambda $

<ChatBox type="info">
请问 $ \lambda $ 参数如何选择？
</ChatBox>


选择正则化超参数 $ \lambda $ 的值非常重要，因为它直接影响模型的表现。选得太大，模型可能会欠拟合；选得太小，模型可能会过拟合。因此，我们需要找到一个合适的 $ \lambda $ 值，使模型在新数据上的表现最佳。

### 常用的选择方法

1. **交叉验证（Cross-Validation）**：
   - 最常用的方法是通过交叉验证（例如K折交叉验证）来选择 $ \lambda $。
   - 基本步骤是：将训练数据分成K个子集，针对每个可能的 $ \lambda $ 值，分别训练模型并计算在每个子集上的验证误差。选择使验证误差最小的 $ \lambda $ 值。
   - 优点：这种方法能够很好地评估模型在新数据上的表现，避免过拟合或欠拟合。

2. **网格搜索（Grid Search）**：
   - 网格搜索是一种系统地搜索超参数空间的方法。你可以在一个预定义的范围内为 $ \lambda $ 选择多个候选值（例如从 $ 0.001, 0.01, 0.1, 1, 10, 100 $ 等）。
   - 然后，使用交叉验证来评估每个 $ \lambda $ 值的性能，选择表现最好的值。
   - 优点：这种方法简单易实现，能够找到接近最优的 $ \lambda $。

3. **随机搜索（Random Search）**：
   - 与网格搜索类似，但随机搜索不会穷举所有可能的超参数组合，而是在超参数空间中随机选择一些点进行测试。
   - 在高维空间或需要调整多个超参数的情况下，随机搜索比网格搜索更高效。

4. **贝叶斯优化（Bayesian Optimization）**：
   - 这种方法基于贝叶斯理论来优化超参数。它通过构建一个代理模型（通常是高斯过程）来估计不同 $ \lambda $ 值的性能，逐步逼近最优解。
   - 贝叶斯优化在高维空间或计算成本高昂的场景下比网格搜索和随机搜索更高效。

5. **正则化路径（Regularization Path）**：
   - 一些机器学习算法（例如Lasso回归）支持计算整个正则化路径，即计算从大到小的一系列 $ \lambda $ 值下的模型系数。
   - 你可以直接查看不同 $ \lambda $ 值下的模型系数的变化，选择一个合适的值。

### 实际操作建议

- **开始时选择范围较大的 $ \lambda $ 候选集**：从较大的范围开始，例如从 $ 10^{-4} $ 到 $ 10^4 $，然后逐步缩小范围，集中在表现较好的区间。
- **使用对数刻度选择 $ \lambda $ 值**：由于 $ \lambda $ 的效果通常是指数级的，建议使用对数刻度来选择一系列候选值（例如：$ 10^{-4}, 10^{-3}, 10^{-2}, \ldots, 10^3, 10^4 $）。
- **考虑模型复杂度和数据量**：数据量较少或噪声较多时，可能需要较大的 $ \lambda $ 来避免过拟合；而当数据量充足时，适度的正则化（较小的 $ \lambda $）通常就足够了。

### 总结

选择 $ \lambda $ 值的最佳方法是使用交叉验证，配合网格搜索或随机搜索等技术来系统地测试和优化。最终的 $ \lambda $ 值应该是在验证数据集上表现最好的值，能够平衡模型的拟合能力和泛化能力。